import { describe } from "vitest";
import { expectEmit } from "../helpers/wrapper";

// Note: The trailing space after the * on empty comment lines is intentional to match autogenerateWarning.ts
const autogenHeader = `/* eslint-disable */


/*
 * This file is automatically generated by typespec-typescript-emitter.
 * 
 * You should not change or manipulate this file, as it will be overwritten.
 * Instead, change the underlying spec.
 */

`;

describe("Interfaces", () => {
  // Basic: Interface with sync methods without errors
  expectEmit(
    "emits basic interface with sync method",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  model User {
    id: uint32;
    name: string;
  }

  interface UserService {
    getAll(): User[];
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type User = {
  id: number,
  name: string
}

export interface UserService {
  getAll(): (User)[];
}
`,
    },
  );

  // Empty Interface
  expectEmit(
    "emits empty interface",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  interface EmptyService {
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export interface EmptyService {}
`,
    },
  );

  // Error-Handling: Methods with @error Union variants → @throws
  expectEmit(
    "generates @throws JSDoc for error models",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  model User {
    id: uint32;
    name: string;
  }

  @error
  model NotFoundError {
    message: string;
  }

  interface UserService {
    getById(id: uint32): User | NotFoundError;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type User = {
  id: number,
  name: string
}

export type NotFoundError = {
  message: string
}

export interface UserService {
  /**
   * @throws {NotFoundError}
   */
  getById(id: number): User;
}
`,
    },
  );

  // Optional Params
  expectEmit(
    "handles optional parameters",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  model User {
    id: uint32;
    name: string;
  }

  interface UserService {
    search(query?: string): User[];
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type User = {
  id: number,
  name: string
}

export interface UserService {
  search(query?: string): (User)[];
}
`,
    },
  );

  // Void Return
  expectEmit(
    "handles void return type",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  interface PingService {
    ping(): void;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export interface PingService {
  ping(): void;
}
`,
    },
  );

  // Complex Types: Nested Models as parameter/return
  expectEmit(
    "handles complex nested types",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  model Address {
    street: string;
    city: string;
  }

  model User {
    id: uint32;
    name: string;
    address: Address;
  }

  model CreateUserInput {
    name: string;
    address: Address;
  }

  interface UserService {
    create(input: CreateUserInput): User;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type Address = {
  street: string,
  city: string
}

export type User = {
  id: number,
  name: string,
  address: Address
}

export type CreateUserInput = {
  name: string,
  address: Address
}

export interface UserService {
  create(input: CreateUserInput): User;
}
`,
    },
  );

  // Error-only: Union only with @error Types → Return never
  expectEmit(
    "returns never when only error types in union",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  @error
  model NotFoundError {
    message: string;
  }

  @error
  model UnauthorizedError {
    message: string;
  }

  interface ErrorOnlyService {
    alwaysFails(): NotFoundError | UnauthorizedError;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type NotFoundError = {
  message: string
}

export type UnauthorizedError = {
  message: string
}

export interface ErrorOnlyService {
  /**
   * @throws {NotFoundError}
   * @throws {UnauthorizedError}
   */
  alwaysFails(): never;
}
`,
    },
  );

  // Multiple error types with success type (without @asyncOp)
  expectEmit(
    "handles multiple error types with success type",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  model Coupon {
    code: string;
    discount: uint32;
  }

  model CreateCouponInput {
    code: string;
    discount: uint32;
  }

  @error
  model InvalidCouponError {
    message: string;
  }

  @error
  model CouponAlreadyExistsError {
    message: string;
  }

  interface CouponService {
    create(input: CreateCouponInput): Coupon | InvalidCouponError | CouponAlreadyExistsError;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type Coupon = {
  code: string,
  discount: number
}

export type CreateCouponInput = {
  code: string,
  discount: number
}

export type InvalidCouponError = {
  message: string
}

export type CouponAlreadyExistsError = {
  message: string
}

export interface CouponService {
  /**
   * @throws {InvalidCouponError}
   * @throws {CouponAlreadyExistsError}
   */
  create(input: CreateCouponInput): Coupon;
}
`,
    },
  );

  // Full example from issue (without @asyncOp for now since library is not configured)
  expectEmit(
    "matches issue example output",
    {
      "main.tsp": `
import "@typespec/http";
using TypeSpec.Http;

namespace test {
  scalar CouponId extends string;

  model Coupon {
    id: CouponId;
    code: string;
  }

  model CreateCouponInput {
    code: string;
  }

  @error
  model InvalidCouponError {
    message: string;
  }

  @error
  model CouponAlreadyExistsError {
    message: string;
  }

  @error
  model CouponNotFoundError {
    message: string;
  }

  interface CouponService {
    op create(input: CreateCouponInput): Coupon | InvalidCouponError | CouponAlreadyExistsError;
    op getById(couponId: CouponId): Coupon | CouponNotFoundError;
    op validateSync(code: string): boolean;
  }
}
`,
    },
    {
      "test.ts": `${autogenHeader}export type CouponId = string

export type Coupon = {
  id: CouponId,
  code: string
}

export type CreateCouponInput = {
  code: string
}

export type InvalidCouponError = {
  message: string
}

export type CouponAlreadyExistsError = {
  message: string
}

export type CouponNotFoundError = {
  message: string
}

export interface CouponService {
  /**
   * @throws {InvalidCouponError}
   * @throws {CouponAlreadyExistsError}
   */
  create(input: CreateCouponInput): Coupon;

  /**
   * @throws {CouponNotFoundError}
   */
  getById(couponId: CouponId): Coupon;

  validateSync(code: string): boolean;
}
`,
    },
  );
});
